# 수 정렬 3

# 문제는 동일하다 다만 자료의 수가 수 정렬 2 보다 10배 늘어나고 메모리 제한이 생겼다.
# 수 정렬 2 문제 코드를 그대로 사용하니 메모리 초과가 일어난다.
# 메모리제한이 256MB에서 -> 8MB로 변경되었다. 

# 확인해보니 리스트를 매우 크게 선언하면 메모리를 간단하게 소모한다고 한다.
# 보통 알고리즘에 시간복잡도와 공간복잡도가 있는게 기억이난다. 
# 공간복잡도는 정말 작은 단위의 메모리도 중요했던 시절 유용했지만 현대에 와서는 많은 발전덕에 중요도가 많이 떨어졌다고 들었다.
# 이 두 복잡도는 밀접하게 연관되어있는데 어느 한쪽이 올라가면 반대쪽이 내려간다.
# 예를들면 시간복잡도가 올라가면 반대로 공간복잡도가 내려간다. 
# 연산을 많이하는 대신 메모리를 적게 쓰던가 메모리를 많이 사용하는 대신 연산을 적게하던가 하는 방식으로
# 해당 문제는 이러한 점을 조율하라는 것 같다.

# 정렬에 비교할 모든 수가 있어야 정렬이 가능한거 아닌가?
# 정렬에 세이브 포인트 같은걸 만들 수 있나?, 세이브포인트가 결국 공간을 사용한다는 것이잖아
# 리스트의 크기를 8MB까지 제한해서 해당 크기까지만 수를 받고 정렬하고 출력 해당 정렬된 리스트는 비우고 다음 수 받기? 
# 다음에는 어떻게 하려고? 다음 수가 직전 리스트 사이 값에 해당한다면? 결국 이전에 정렬된 리스트를 기억해야 삽입이라도 할텐데? 
# 정렬을 끝낸 맨 앞과 맨 끝의 수만 기억하기? 이것도 다음 값이 맨 끝값들의 사이 값이 아니라는 조건이 필요함 

# AI에게 물어보니 Timsort는 임시 배열을 만들며, 자료 갯수가 (1 ≤ N ≤ 10,000,000) 일때 메모리 사용량을 구해보라고했다.
# 자료의 개수 (N): 10,000,000 (천만) 개, 80,000,000 바이트 / 1,048,576 바이트/MB ≈ 76.3 MB
# 제한된 8MB를 한참 웃도는 수치다. 천재들이 만들어둔 Timsort는 사용할 수 없으며 직접 만들어야한다.

# 힌트를 좀 얻어봤는데 "이 수는 10,000보다 작거나 같은 자연수" 그래 예제에도 같은 수가 포함이 되어있더라 이걸 놓친게 큰 것 같다.
# 1 ~ 10000에 해당하는 각 배열을 만든다.
# index 0부터 숫자 1을 의미한다.
# 내부 숫자를 모두 0으로 초기화한다.
# 입력값이 들어오면 해당 인덱스의 숫자를 꺼내서 + 1 하고 저장한다.
# 반복문을 이용해 각 index에 해당하는 값을 반복 출력한다.
# 이러면 원본을 기억할 필요도 없다. Counting sort라고 이미 있다고 한다.

import sys
input = lambda: sys.stdin.readline().rstrip()

sortList = [0] * 10000 # 0 ~ 9999 -> 1 ~ 10000 인덱스 접근시 -1 해주기

ran = int(input()) # 입력될 자료 수

for i in range(ran):
    num = int(input())
    sortList[num - 1] = sortList[num - 1] + 1


for i in range(10000):
    for j in range(sortList[i]):
        print(i + 1)