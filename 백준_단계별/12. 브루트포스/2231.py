# 분해합
# 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다. 
# 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다.
# 따라서 245는 256의 생성자가 된다. 
# 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다. 
# 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

# 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
# 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
# 첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

# 입력값이 꽤 크다? 브루트포스를 의도하긴 하나 1~1000000 의 모든 분해합을 시도하는 경우를 허용하지 않는 듯한 의도인듯 하다.
# 브루트포스이니 따로 계산적인 방식도 유도하지 않는다.
# 그럼 방법은 들어온 입력값 기준으로 범위를 줄이는 방식을 원하는 것 같다.
# 예를 들면 분해합이 250인 경우 생성자가 250보다 커질수도 없어 1과 같이 터무니 없이 작은 값이 될 수도 없을 것이다.

# 이러한 나올 수 있는 최소, 최대 범위를 구하는 방식을 찾으면 될 것 같다.
# 분해합의 각 자리수는 0~9까지 입력값 n의 자리수보다 낮은 자리수의 생성자가 나오는 경우가 있을까 많은 듯 2개 이상도?
# 9999999 -> 9*7=63 한 자리 수 증가가 최대인듯

# 우선 생성자가 없을 때 0 출력해주고
# 정확하게 구할 필요없이 대충 절반 입력값에 절반 잘라서 하면? 중간에 찾으면 바로 중단하는 것 까지
# 맞았다. 대충 반으로 갈랐는데 브론즈 2 문제인 이유가 있는듯


# 제대로 된걸 찾아봤는데 가장 효율적인 범위 탐색은 아래와 같다는 듯 
# start = max(1, N - len(str(N)) * 9)
# end = N

# 접근법 자체는 위에 생각했던 "9999999 -> 9*7=63 한 자리 수 증가가 최대인듯" 이것으로 꽤 도달했었는데
# 여기서 더 확장을 시켜야했음 "N - len(str(N)) * 9)" 이게 생각은 할법한데 이거에 대한 근거 + 증명을 생각하는게 어려움
# 사실 의도한대로 돌아가기만 정답이긴함 

N = int(input())

for i in range(N//2, N):
    digits = list(map(int, str(i)))
    total = i + sum(digits)
    if total == N:
        print(i)
        break

    if i == N-1:
        print(0)
