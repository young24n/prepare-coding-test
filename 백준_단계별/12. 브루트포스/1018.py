# 체스판 다시 칠하기
# --문제내용--
# MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 
# 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 
# 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다.

# 체스판은 검은색과 흰색이 번갈아서 칠해 구체적으로, 
# 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 
# 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 
# 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 
# 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.

# 8*8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각
# 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성

# 첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 
# 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.

# 첫째 줄에 지민이가 다시 칠해야 하는 정사각형(체스칸의) 개수의 최솟값을 출력한다.
# ---

# 설명이 조금 난해한데 요약하자면
# N x M 크기의 보드에서, 8x8 크기로 잘라낼 수 있는 모든 경우를 다 시험해보고, 
# 각 경우에서 가장 적은 수의 정사각형(블럭)만 다시 칠해서 완벽한 체스판으로 만들어 칠한 횟수를 출력하는 것 

# 여기서 정사각형이란 여러개 칸을 한 덩어리로 표현하는게 아닌(ex 2*2칸 3*3칸 등등의 정사각형 아님 단 하나의 칸을 의미)단 하나의 체스칸이라 생각하면 된다.
# 예제를 예시로 들자면, 아래와 같이 이미 M*N이 8*8로 제공된 상태이면 다른 8*8을 찾을 필요가 없다. 
# 그리고 4번째 줄에 B가 한 칸 잘못 들어가 있는 것을 확인 할 수 있다. 답은 그래서 1칸이다.

# 예제 입력 1
# 8 8
# WBWBWBWB
# BWBWBWBW
# WBWBWBWB
# BWBBBWBW # 여기
# WBWBWBWB
# BWBWBWBW
# WBWBWBWB
# BWBWBWBW
# 예제 출력 1
# 1

# 만약 9 * 9 의 경우 
# 좌측 상단 끝 기준 8*8 1개, 
# 우측 상단 끝 기준 8*8 1개, 
# 좌측 하단 끝 기준 8*8 1개,
# 우측 하단 끝 기준 8*8 1개
# 이렇게 4가지의 8*8의 체스판 경우의 수를 볼 수 있다. 
# 이 중에서 정상적인 배치의 칸이 최대한 많은 8*8 체스판을 찾아서 다시 칠해야 하는 칸이 가장 적은 것을 찾으면 된다.

# 음 그냥 간단하게 8*8 인덱스를 지정하고 거기서 한칸씩 계속 움직이고 
# 해당 8*8 배열을 전부 순회하며 정상적이지 않은 요소의 갯수를 세어 한 곳에 모두 저장하여 min()으로 가장 적은 것을 출력하면 되겠다

# 배치를 검증하고 카운팅 하는 것을 쉽다. 다만 인덱스를 옮기는게 쉽게 와닿지 않는다.
# 사람 시점에서는 이 덩어리를 옮긴다는 개념으로 다가오는데 인덱스는 그런 느낌이 아닌 철저하게 지정해야하니 
# 10*8, 23*9 등등 감을 잡기 어렵긴하다. 
# 멀티미디어에서 이미지 픽셀 다룰 때 비슷한 걸 해보긴했는데 어려웠던 것으로 기억한다.
# ---

M, N = map(int, input().split(' '))

board = []

for i in range(M):
    board.append(list(input()))

# print(board)

# ---
# 우선 여기까지 2차원 배열이 잘 만들어 지는지 확인한다. 
# 파이썬은 문자열(str)에 list()로 감싸주면 알아서 때서 각 글자를 하나의 요소로 바꿔준다.
# 음 나중에 js로 모든 문제를 다시 풀어봐야겠다.
# ---

start_col = 0
end_col = 8

start_row = 0
end_row = 8

# ---
# 우선 2중 반복문을 쓰는 건 당연하다. 2차원 배열을 탐색하는 것이니
# 다만 반복문의 시작점과 끝점에 의해 어떻게 형성되는지 잘 와닿지 않았다.
# 그래서 걍 출력시켜서 알아보기로 했다. 입력은 예제 2번을 이용했다. 
# 첫 8*8이 모두 B로 되어있어 아주 보기 편하게 구성되어있다. 디버깅용으로 1번보다 좋으니 추천
# ---

# for i in range(start, end): # try range -> 0,8 / 1,9 / 1,9 -> 이것으로 외부 반복문은 아래로 한 칸 이동하는 것을 확인
#     for j in range(0, 8):   # try range -> 0,8 / 1,9 / 0,8 -> 이것으로 내부 반복문은 우측으로 한 칸 이동하는 것을 확인
        # if board[i][j] == 'B':
            # countB += 1
        # print(board[i][j], end='')
    # print()

# print(countB)

# ---
# 다음은 검증 시스템을 먼저 구현하자 대충 생각해둔 것은
# 1. 두가지 버전의 8*8 정상 배치의 list를 하나씩 준비한다. (1. 첫 글자가 W부터 시작하는 격자무늬 2. 첫 글자가 B로 시작하는 격자무늬)
# 2. 비교 대상 list가 한번 순회할때 정상 list의 같은 인덱스를 순차적으로 돌며 서로의 값을 비교하고 틀리면 카운트한다.
# 비교는 W,B 버전 두가지 모두 비교하고 가장 적은 것을 하나 기록한다.
# 3. 해당 결과를 result list에 저장한다.
# 4. 반복, -> list에서 최소값을 뽑아내어 출력 

WFirstBoard = [
list('WBWBWBWB'),
list('BWBWBWBW'),
list('WBWBWBWB'),
list('BWBWBWBW'),
list('WBWBWBWB'),
list('BWBWBWBW'),
list('WBWBWBWB'),
list('BWBWBWBW')
]

BFirstBoard = [
list('BWBWBWBW'),
list('WBWBWBWB'),
list('BWBWBWBW'),
list('WBWBWBWB'),
list('BWBWBWBW'),
list('WBWBWBWB'),
list('BWBWBWBW'),
list('WBWBWBWB')
]

result = []

# 우측으로 한 칸씩 이동하다가 우측 인덱스 끝에 다다르면 내부(우측 이동 담당) 반복문 범위를 초기화하고 
# 외부 반복문(아래 이동 담당)을 범위를 한 칸 증가시키고 아래쪽과 우측 모두 끝에 도달할 때까지 반복하면 될 것 같다.
# 인덱스의 끝은 어떻게 판단할까? 초기 입력된 M,N이 있으니 그것으로 판단하면 될 것 같다.

# 체스판의 전체 크기인 M, N은 가장 작은 값이 8, 8로 들어옴 
# 때문에 M,N 범위만큼 점점 증가하는 i, j를 이용해서 기존 탐색 범위에 더해서하거나 빼는 방식으로 전체 범위에서 인덱스를 한 칸씩 옮기는데
# 이미 start/end,row/col를 이용해서 이미 체스판 전체의 상당한 부분인 8*8 칸을 탐색하고 있는데 
# 거기에 체스칸 전체 범위인 M,N을 그대로 쓰면 인덱스 범위를 넘어버리기 때문에 -7을 통해 내부 반복문에서 이미 지정하고 있는 8*8을 제외한 것
for i in range(M - 7): 
    for j in range(N - 7):
        countW = 0
        countB = 0 
        for row in range(start_row + i, end_row + i):
            for col in range(start_col + j, end_col + j): 
                if board[row][col] != WFirstBoard[row - i][col - j]: # 비교 대상은 8 * 8 이상의 인덱스가 없으니 i,j가 증가하는 만큼 빼줘야함
                    countW += 1
                if board[row][col] != BFirstBoard[row - i][col - j]:
                    countB += 1
        result.append(countB)
        result.append(countW)  
      
print(min(result))

