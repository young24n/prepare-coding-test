# 벌집

# 그림과 같이 육각형으로 된 벌집이 있다. 
# 중앙에 1번 집이 있고 2, 3, 4 ...까지 1번 방을 중심으로 원을 그리며 벌집을 형성하고 있다. 
# 중앙 1번 방에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지 계산하는 프로그램 작성하시오

# 1번 방을 중심으로 나머지 N번 방들은 원을 그리며 둘러싼 형태이다.
# 입력으로 특정 방 번호가 주워졌을 때 1번 부터 해당 번호까지 최소 거리로 몇개의 방을 통과하는지 계산해야한다.
# 여기서 방의 갯수는 시작과 끝을 반영한다.(1부터 입력된 N번 방도 갯수에 포함)

# 그림을 보면 이해하기 쉬운데 직선 거리를 세어보면 거리 별로 이동하는 방의 갯수가 고정되어있는 것을 알 수 있다.
# 이걸 기준으로 각각 1, 7, 19, 37, 61을 경계로 해당 숫자를 넘으면 이동할 방의 갯수가 늘어나는 것을 알 수 있다.
# 정확히 2, 8, 20, 38, 62가 되면 이동할 방의 갯수가 1 늘어난다. 
# 여기서 규칙성을 찾으면 된다.
# N은 1 ≤ N ≤ 1,000,000,000 이기에 숫자 하나하나에 if로 대응하는 것은 불가능하다.
# 6, 12, 18, 24 숫자가 각각 이렇게 증가한다. 증가값이 6의 배수인듯 하다.

# 우선 이동해야하는 방 N을 입력받는다.
# 무한 반복을 만든다. while을 이용한다. 1을 입력 받으면 1을 출력하게 반복문 밖에 만든다.
# 그다음 비교할 기본 값으로 2~7을 선택하고 각각 변수에 초기화한다. (less, greater) 
# 2~7, 8~19, 20~37, 38~61, 62... 이러한 방식이니 각 비교 변수에 배수를 더해줄 변수를 만든다(standard)
# standard는 12로 초기화되어있다. 루프 마지막에 해당 값에 6씩 더해진다. 
# standard는 루프 시작시 less와 greater에 더해진다.  
# 이것을 반복하며 N이 어디 사이 값인지 알아낸다.
# counter를 추가할까 했지만 standard를 6으로 나눠 몫을 구하는게 더 좋은 것 같다.
# 몫을 출력한다.

# -시간초과-
# 하긴 좀 무식한 방법이긴했다. 절차를 반으로 줄여보자

N = int(input())

if N == 1:
    print('1')
else:
    count = 1
    max_room_num = 1
    while max_room_num < N:
        max_room_num += 6 * count
        count += 1
    print(count)