# 진법 변환 2
#---
# 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성
# 이건 딱히 제공되는게 없다.
#---
# 10 진수을 특정 진법으로 변환하는 계산식의 공통점을 이용해야할 것 같다.
# 데이터 논리회로 또는 자료구조에서 10진수를 특정 진수로 변환하는 과정에서 사용하는 방법인(보통 2진수로 변환)
# **값 / 2(바꾸고 싶은 진법 여기서는 2진수) = 몫, 나머지** 이것이 있다. 몫이 0이 될때까지 몫을 2로 반복적으로 나누고 
# 그때마다 생성되는 나머지를 모두 기록하면 해당 진법으로 변환하는 것이다.
#---
# 탐색도중 재귀를 사용하는 스포를 당했는데 취향이 아니긴 하지만 이번 문제에서는 딱 맞는 형태이긴하다.
#---
# 입력 값으로 값과 진법을 입력받는다.
# 입력 값을 진법으로 나누어 몫과 나머지를 만들고 해당 나머지 값을 배열에 저장한다. 
# 이때 나머지가 10(A)~35(Z)라면 변환하여 저장한다.
# 그리고 위 기능을 포함한 몫을 return 하는 함수로 만든다.
# 입력된 몫이 0이면 해당 함수를 종료하도록 한다.

# 시간제한 0.5초인데 의도된 것인지 모르겠지만 if을 여러개 못쓰게 하는 것으로 추측된다. 따로 테스트 해보고 싶진 않다.
# 변환과정을 그냥 배열에서 선택하는 것으로 하려고 한다.(이것도 이미 스포당한거지만 똑똑한 방식이라 생각된다.)
# 왜 틀린지 전혀 모르겠다가. 까다롭게도 이진수와 같이 숫자의 순서가 오른쪽이 정방향인 것 또한 보는 거 같다.
# unshift를 생각하긴 했는데 JS에만 있고 파이썬에는 없다고 한다. 그래서 내부 함수 중 reversed를 사용하기로 했다.

digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
stack = []

def anyEncode(value, base):
    if value != 0:
        quotient = value // base
        remainder = value % base
        stack.append(digits[remainder])
        anyEncode(quotient, base)
    else:
        return 0 

V, B = map(int, input().split(" "))
anyEncode(V, B)

print(''.join(reversed(stack)))