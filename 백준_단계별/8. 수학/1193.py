# 분수찾기

# 무한히 큰 배열에 다음과 같이 분수들이 적혀있다.
# 1/1 1/2 1/3 1/4 1/5 …
# 2/1 2/2 2/3 2/4 … …
# 3/1 3/2 3/3 … … …
# 4/1 4/2 … … … …
# 5/1 … … … … …
# … … … … … …

# 이와 같이 나열된 분수들을 1/1 → 1/2 → 2/1 → 3/1 → 2/2 → … 
# 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.

# X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.
# 입력 첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.
# 출력 첫째 줄에 분수를 출력한다.

# 예제 입력 1 
# 1
# 예제 출력 1 
# 1/1
# 예제 입력 2 
# 2
# 예제 출력 2 
# 1/2
# 예제 입력 3 
# 3
# 예제 출력 3 
# 2/1

# 무한히 있는 배열을 지그재그로 순회한다. 이때 X가 주워질때 X번째에 있는 분수를 출력하시오

# 수학문제이고 제한시간이 매우 짧고 범위 또한 매우커서 모든 분수를 순회하는 형식은 아닐꺼다. 
# 결국 규칙성을 찾아 즉석으로 계산해야한다. 
# 감이 전혀 안잡힌다.
# 몇몇 규칙을 찾기는 했지만 분수와 분모의 증가를 연관시키는 것을 찾지는 못했다.

# 힌트와 풀이를 좀 봤는데 설명이 난해하다. 
# 그래서 규칙성에 대한 힌트만 조금 얻을 수 있었다. 
# 그래도 뭘 하려는 것인지는 알 수 있어서 내 방식대로 해석하여 설명을 풀어보겠다
# 우선 순차적인 흐름에 해당하는 규칙에 집중했던 것이 문제였다.
# 대각선을 기준으로 보면된다. 
# 각 대각선 라인을 기준으로 모든 요소의 분자와 분모의 합이 모두 같은 것과 요소의 갯수 또한 일치하는 것을 볼 수 있다. 
# 예를 들면 
# 1 라인: 1/1 -> 합 2, 요소 1개
# 2 라인: 1/2, 2/1 -> 합 3, 요소 2개
# 3 라인: 3/1, 2/2, 1/3 -> 합 4 , 요소 3개
# 4 라인: 4/1(4+1=5), 3/2(3+2=5), 2/3(2+3=5), 1/4(1+4=5) -> 합 5, 요소 4개 
# 5 라인: 5/1, 4/2, 3/3, 2/4, 1/5 -> 합 6, 요소 5개
# 이렇게 고정된 합계를 유지하는 것이 보인다.

# 각 라인의 요소의 갯수가 같다는 것과
# 각 라인에 해당하는 값의 분모와 분자의 합이 라인+1 을 넘지 않는 것을 확인 할 수 있다.

# 아래는 X가 36일때까지 진행해본 인덱스이다.
# 각 라인의 마지막에 해당하는 인덱스를 보자
# 1라인: 1
# 2라인: 3
# 3라인: 6
# 4라인: 10
# 5라인: 15

# 1  2  6  7  15 16 28 29
# 3  5  8  14 17 27 30
# 4  9  13 18 26 31
# 10 12 19 25 32
# 11 20 24 33
# 21 23 34
# 22 35
# 36

# 언듯보면 규칙이 없어보인다. 이번에는 요소의 갯수도 함께보자
# 1라인: 1, 1개 (1 = 1)
# 2라인: 3, 2개 (1+2 = 3)
# 3라인: 6, 3개 (1+2+3 = 6)
# 4라인: 10, 4개 (1+2+3+4 = 10)
# 5라인: 15, 5개 (1+2+3+4+5 = 15) 
# 직전 요소의 갯수를 모두 합하니 해당 라인의 마지막 요소의 인덱스 번호와 정확하게 일치한다.
# 그리고 요소를 합하는 식을 보라(1+2+3+4+5+... = n) 어디서 많이 보지 않았나? 이미 알던 공식이 떠오른다.
# 시점상 24265 문제를 먼저 풀었는데 등차 수열의 합 공식을 해당 문제에서 사용했었다. 
# n(n+1) / 2 이것이다. 원리는 직접 찾아보자 

# 이것으로 X가 어떤 라인에 있는지 파악할 수 있게 되었다.
# 구현은 합공식, 누적합 차이가 없어 보여 원하는 것을 사용해도 될 것 같다. 
# 범위에 해당하는 라인을 구하기 위해서는 결국 반복문을 사용해야하며 딱히 depth가 늘어날 것 같지도 않다

# 누적합으로 더하는 값을 1씩 증가시켜 계속 더하다가 X를 넘어서는 순간이 있을 것이다.
# 만약 넘어선다면 반복 횟수를 체크하던 직전의 count 값을 가져온다. 
# 해당 count 값이 라인의 수가 된다. 이후 이것을 L로 칭하겠다.
# 그러면 X는 L라인에 해당하는 인덱스가 된다.
# 그리고 누적합으로 X의 값을 넘어버린 sum이 해당 라인의 마지막 인덱스이다.
# 해당 라인의 분자와 분모의 합은 항상 L+1 임을 위에서 확인했었다.
# 여기서 중요한 점은 L이 짝수이냐 홀수이냐에 따라 해당 라인의 마지막 인덱스의 분수가 달라진다는 점이다.

# 이것을 보자 각 라인의 마지막 인덱스 지점에 해당되는 부분을 () 했다.
# 각 라인의 마지막 인덱스에서 인덱스가 줄어드는 방향으로 이동해보아라

# 분수
# (1/1) 1/2 (1/3) 1/4 (1/5) 1/6
# (2/1) 2/2  2/3  2/4  2/5
#  3/1  3/2  3/3  3/4
# (4/1) 4/2  4/3
#  5/1  5/2
# (6/1)

# 인덱스
# (1)  2  (6)  7  (15) 16
# (3)  5   8   14  17
#  4   9   13  18
# (10) 12  19
#  11  20
# (21)

# 라인이 홀수이냐 짝수이냐에 따라 분자와 분모의 위치가 완전 정반대이다.
# 역방향의 흐름 또한 다른데
# 홀수의 경우 분자가 증가하고 분모가 줄어드는 형태
# 짝수의 경우 분자가 줄어들고 분모가 증가하는 형태로 인덱스의 흐름이 형성된다.

# 라인 1: (1/1)                                     (라인: 홀수, ..)
# 라인 2: (2/1) -> 1/2                              (라인: 짝수, 분자 감소/분모 증가)
# 라인 3: (1/3) -> 2/2 -> 3/1                       (라인: 홀수, 분자 증가/분모 감소)
# 라인 4: (4/1) -> 3/2 -> 2/3 -> 1/4                (라인: 짝수, 분자 감소/분모 증가)
# 라인 5: (1/5) -> 2/4 -> 3/3 -> 4/2 -> 5/1         (라인: 홀수, 분자 증가/분모 감소)
# 라인 6: (6/1) -> 5/2 -> 4/3 -> 3/4 -> 2/5 -> 1/6  (라인: 짝수, 분자 감소/분모 증가)

# 이를 이용해 X 인덱스의 정확한 분수를 구할 수 있게 된다.
# **이제 구현을 요약하자면**

# 반복문으로 누적합 X를 넘긴 마지막 인덱스 sum를 구한다. 반복 횟수를 구하던 count(=L 라인)를 구한다.
# sum이 X를 넘거나 같은 값이 되면 반복을 중단하고 라인이 짝수인지 홀수인지 판단한다.
# 짝수라면 라인-1/1 부터 분자 감소/분모 증가 하기
# 홀수라면 1/라인-1 부터 분자 증가/분모 감소 하기
# 진행 횟수는 X와 sum의 차를 구한 값 만큼 진행하면 된다.
# 구해진 값을 출력한다.

X = int(input())

count = 0

sum = 0
add = 1

while sum < X:
    sum += add
    add += 1
    count += 1

diff = sum - X
if count % 2 == 0:
    numerator = count - diff
    denominator = 1 + diff
else:
    numerator = 1 + diff
    denominator = count - diff
print(f"{numerator}/{denominator}")