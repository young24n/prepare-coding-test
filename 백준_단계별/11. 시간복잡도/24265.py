# 알고리즘 수업 - 알고리즘의 수행 시간 4

# 첫째 줄에 코드1 의 수행 횟수를 출력한다.
# 둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다.
# 단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력

# 변형된 MenOfPassion 알고리즘은 다음과 같다. 
# 해당 의사코드를 파이썬으로 바꿀때 조심해야한다. 
# 1 to n - 1 -> range(1, n) i + 1 to n -> (i+1, n+1) 이렇게 해야 올바르게 작동한다.
# 파이썬은 range(n)을 사용하면, n-1 회까지 작동한다. 
# range에 적은 횟수는 유지하되 이는 index가 0부터 시작하기 때문에 
# 마지막 n을 실행하지 않음으로 횟수를 맞춘다. 그런데 시작 지점을 0이 아닌 1로 해두었기에 1~n-1이 자동으로 성립된다.
# 의사코드에 적혀있는 것은 이미 파이썬에 적용되어 있다는 뜻이다.
# 단 내부에 있는 반복문에 대해서는 n회차가 무시됨으로 n+1로 수정 해줘야 한다. 

# MenOfPassion(A[], n) {
#     sum <- 0;
#     for i <- 1 to n - 1
#         for j <- i + 1 to n
#             sum <- sum + A[i] × A[j]; # 코드1
#     return sum;
# }

# 솔직히 이렇게 입력값이 변경된 경우 잘모르겠다. 
# 찾아보니 다른 수학적 개념 또한 알고 있어야한다. 등차수열인데 이는 생략하겠다.
# 여기서 중요한 점은 인덱스인 i와 j의 값의 변화에 집중하면 안된다, 실행 횟수에 집중하도록 하자
# 실질적인 반복을 담당하는 j의 반복 횟수를 i가 증가함에 따라 j가 어떻게 되는지 확인 하면 된다.

# 아래의 코드를 실행해 보자.
# 알고리즘과 같다만 ij를 출력하고 n은 예제 입력과 같은 7로 변경해두었다.
# for i in range(1, 7):
#     print('i: ',i)    
#     for j in range(i + 1, 7 + 1):
#         print('j: ',j)
# i는 정직하게 움직인다만 j가 번거롭게 움직이고 있다.
# 여기서 주목할 점은 j의 숫자가 아닌 i가 몇 일때 j가 몇 번 나타나느냐(=실행) 이다.
# 체크를 해보면 [i=1 -> j 6번 실행], [i=2 -> j 5번 실행], [i=3 -> j 4번 실행], [i=4 -> j 3번 실행], [i=5 -> j 2번 실행], [i=6 -> j 1번 실행] 끝
# i가 증가할 수록 내부 반복문인 j의 실행 횟수가 감소하는 형태가 확인 된다.
# 모든 실행 횟수를 더하면 총 21, 예제 정답과 같다.

# j의 각 실행 횟수는 n-i를 따라간다. n-1 n-2 n-3...1회 이것을 모두 더하면 총 실행 횟수가 된다.
# 이는 1씩 감초하는 등차수열과 같은데 해당 등차 수열의 합 공식은 다음과 같다.(1~n 까지의 합 = n(n+1)/2)
# 합계 = n(n-1) / 2 원리는 알아서 찾아보도록, 나눌 때 몫 기준 나누기 이용(n // 2) 나누기를 하면 실수(float)로 출력됨

n = int(input())
print(n * (n-1) // 2) # (n^2 - n) / 2 가장 높은 차수 2가 있다 O(n^2)
print(2)
